<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat & Call App with Screen Share</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        
        /* ビデオのフェードインアニメーション */
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .video-container { animation: fadeIn 0.3s ease-out forwards; }
    </style>
</head>
<body class="bg-slate-900 text-slate-200 overflow-hidden">
    <div id="root" class="h-screen w-screen"></div>

    <script type="text/babel" data-type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        // WebRTCのシグナリングに必要な doc, setDoc, getDoc, updateDoc 等を追加
        import { getFirestore, collection, addDoc, onSnapshot, query, doc, setDoc, getDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDqbtZUCkdO4p7nCFBPEVO4XtsBTVzIk9c",
            authDomain: "meetapp-52325.firebaseapp.com",
            projectId: "meetapp-52325",
            storageBucket: "meetapp-52325.firebasestorage.app",
            messagingSenderId: "623449233232",
            appId: "1:623449233232:web:f25c2a8641c135b509be55",
            measurementId: "G-XMXN52QVWK"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        const { useState, useEffect, useRef } = React;

        const createIcon = (paths) => ({ size = 24, className = "", title }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {title && <title>{title}</title>}
                {paths}
            </svg>
        );

        const Mic = createIcon(<React.Fragment><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z" /><path d="M19 10v2a7 7 0 0 1-14 0v-2" /><line x1="12" y1="19" x2="12" y2="22" /></React.Fragment>);
        const MicOff = createIcon(<React.Fragment><line x1="2" y1="2" x2="22" y2="22" /><path d="M18.89 13.23A7.12 7.12 0 0 0 19 12v-2" /><path d="M5 10v2a7 7 0 0 0 12 5" /><path d="M15 9.34V5a3 3 0 0 0-5.68-1.33" /><path d="M9 9v3a3 3 0 0 0 5.12 2.12" /><line x1="12" y1="19" x2="12" y2="22" /></React.Fragment>);
        const Camera = createIcon(<React.Fragment><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z" /><circle cx="12" cy="13" r="3" /></React.Fragment>);
        const CameraOff = createIcon(<React.Fragment><line x1="2" y1="2" x2="22" y2="22" /><path d="M7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16" /><path d="M9.5 4h5L17 7h3a2 2 0 0 1 2 2v7.5" /><path d="M14.121 15.121A3 3 0 1 1 9.88 10.88" /></React.Fragment>);
        const MonitorUp = createIcon(<React.Fragment><path d="m9 10 3-3 3 3" /><path d="M12 7v8" /><rect width="20" height="14" x="2" y="3" rx="2" /><path d="M12 17v4" /><path d="M8 21h8" /></React.Fragment>);
        const Phone = createIcon(<React.Fragment><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z" /></React.Fragment>);
        const PhoneOff = createIcon(<React.Fragment><path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91" /><line x1="22" y1="2" x2="2" y2="22" /></React.Fragment>);
        const MessageSquare = createIcon(<React.Fragment><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" /></React.Fragment>);
        const Hash = createIcon(<React.Fragment><line x1="4" y1="9" x2="20" y2="9" /><line x1="4" y1="15" x2="20" y2="15" /><line x1="10" y1="3" x2="8" y2="21" /><line x1="16" y1="3" x2="14" y2="21" /></React.Fragment>);
        const UserIcon = createIcon(<React.Fragment><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" /><circle cx="12" cy="7" r="4" /></React.Fragment>);
        const X = createIcon(<React.Fragment><line x1="18" y1="6" x2="6" y2="18" /><line x1="6" y1="6" x2="18" y2="18" /></React.Fragment>);
        const Menu = createIcon(<React.Fragment><line x1="4" y1="12" x2="20" y2="12" /><line x1="4" y1="6" x2="20" y2="6" /><line x1="4" y1="18" x2="20" y2="18" /></React.Fragment>);
        const Send = createIcon(<React.Fragment><line x1="22" y1="2" x2="11" y2="13" /><polygon points="22 2 15 22 11 13 2 9 22 2" /></React.Fragment>);
        const AlertCircle = createIcon(<React.Fragment><circle cx="12" cy="12" r="10" /><line x1="12" y1="8" x2="12" y2="12" /><line x1="12" y1="16" x2="12.01" y2="16" /></React.Fragment>);

        // --- CallUI (通話画面) ---
        const CallUI = ({ localStream, remoteStream, isAudioEnabled, isVideoEnabled, isScreenSharing, toggleAudio, toggleVideo, toggleScreenShare, endCall, userName }) => {
            return (
                <div className="flex-1 flex flex-col bg-slate-900 relative">
                    <div className="flex-1 p-4 md:p-8 flex flex-col md:flex-row items-center justify-center gap-4 relative overflow-hidden">
                        
                        {/* リモートビデオ (相手の映像) */}
                        <div className="video-container flex-1 w-full max-w-4xl aspect-video bg-slate-950 rounded-2xl overflow-hidden shadow-2xl border border-slate-800 relative group flex items-center justify-center">
                            <video 
                                ref={(el) => { if (el && remoteStream) el.srcObject = remoteStream; }}
                                autoPlay playsInline 
                                className="w-full h-full object-cover bg-slate-900 absolute inset-0"
                            />
                            {!remoteStream?.active && (
                                <div className="absolute inset-0 flex flex-col gap-3 items-center justify-center bg-slate-800/80 z-10">
                                    <div className="w-10 h-10 border-4 border-indigo-500 border-t-transparent rounded-full animate-spin"></div>
                                    <span className="text-slate-300 font-medium">相手の参加を待機中...</span>
                                </div>
                            )}
                            <div className="absolute bottom-4 left-4 bg-slate-900/80 backdrop-blur-md px-3 py-1.5 rounded-lg flex items-center gap-2 border border-slate-700/50 shadow-lg z-20">
                                <span className="text-sm font-medium">通話相手</span>
                            </div>
                        </div>

                        {/* ローカルビデオ (自分の映像 - 右下に小さく表示) */}
                        <div className="video-container w-40 md:w-64 aspect-video bg-slate-950 rounded-xl overflow-hidden shadow-2xl border border-slate-700 relative md:absolute md:bottom-28 md:right-8 z-30 group">
                            {isVideoEnabled ? (
                                <video 
                                    ref={(el) => { if (el && localStream) el.srcObject = localStream; }}
                                    autoPlay playsInline muted 
                                    className={`w-full h-full object-cover transition-transform duration-300 ${!isScreenSharing ? 'transform scale-x-[-1]' : ''}`}
                                />
                            ) : (
                                <div className="w-full h-full flex flex-col items-center justify-center text-slate-500 bg-slate-800 gap-2">
                                    <UserIcon size={24} className="text-slate-600" />
                                    <span className="text-xs font-medium">カメラオフ</span>
                                </div>
                            )}
                            
                            <div className="absolute bottom-2 left-2 bg-slate-900/80 backdrop-blur-md px-2 py-1.5 rounded flex items-center gap-1.5 border border-slate-700/50">
                                <div className={`w-2 h-2 rounded-full ${isAudioEnabled ? 'bg-green-500' : 'bg-rose-500'}`}></div>
                                <span className="text-xs font-medium text-white truncate max-w-[80px]">あなた</span>
                            </div>
                        </div>

                    </div>

                    <div className="h-24 bg-slate-950 border-t border-slate-800 flex items-center justify-center gap-4 md:gap-6 px-4 pb-4">
                        <button onClick={toggleAudio} className={`w-14 h-14 rounded-full flex items-center justify-center transition-all duration-200 ${isAudioEnabled ? 'bg-slate-700 hover:bg-slate-600 text-white' : 'bg-rose-500/20 text-rose-500 hover:bg-rose-500/30'}`}>
                            {isAudioEnabled ? <Mic size={24} /> : <MicOff size={24} />}
                        </button>
                        <button onClick={toggleVideo} className={`w-14 h-14 rounded-full flex items-center justify-center transition-all duration-200 ${isVideoEnabled ? 'bg-slate-700 hover:bg-slate-600 text-white' : 'bg-rose-500/20 text-rose-500 hover:bg-rose-500/30'}`}>
                            {isVideoEnabled ? <Camera size={24} /> : <CameraOff size={24} />}
                        </button>
                        <button onClick={toggleScreenShare} className={`w-14 h-14 rounded-full flex items-center justify-center transition-all duration-200 ${isScreenSharing ? 'bg-indigo-500 hover:bg-indigo-600 text-white shadow-lg shadow-indigo-500/30' : 'bg-slate-700 hover:bg-slate-600 text-white'}`}>
                            <MonitorUp size={24} />
                        </button>
                        
                        <div className="w-px h-8 bg-slate-700 mx-2"></div>
                        
                        <button onClick={endCall} className="w-16 h-16 rounded-full flex items-center justify-center bg-rose-500 hover:bg-rose-600 text-white transition-all duration-200 hover:scale-105 shadow-lg shadow-rose-500/30">
                            <PhoneOff size={28} />
                        </button>
                    </div>
                </div>
            );
        };

        // --- ChatUI (チャット画面) ---
        const ChatUI = ({ activeChat, user, userName }) => {
            const [messages, setMessages] = useState([]);
            const [inputText, setInputText] = useState("");
            const messagesEndRef = useRef(null);

            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [messages]);

            useEffect(() => {
                if (!user) return; 

                const q = query(collection(db, 'channels', activeChat.id, 'messages'));
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const msgs = [];
                    snapshot.forEach((doc) => {
                        msgs.push({ id: doc.id, ...doc.data() });
                    });
                    msgs.sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
                    setMessages(msgs);
                }, (error) => {
                    console.error("Firestore error:", error);
                });

                return () => unsubscribe();
            }, [activeChat.id, user]);

            const handleSend = async (e) => {
                e.preventDefault();
                if (!inputText.trim() || !user) return;
                
                const newMsg = {
                    user: userName,
                    avatar: userName.substring(0, 2).toUpperCase(),
                    text: inputText,
                    createdAt: Date.now(),
                    time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})
                };
                setInputText("");

                try {
                    await addDoc(collection(db, 'channels', activeChat.id, 'messages'), newMsg);
                } catch (error) {
                    console.error("Error adding message:", error);
                }
            };

            return (
                <div className="flex-1 flex flex-col bg-slate-800">
                    <div className="flex-1 overflow-y-auto p-4 md:p-6 space-y-6">
                        {messages.length === 0 ? (
                            <div className="h-full flex items-center justify-center text-slate-500 text-sm">
                                まだメッセージはありません
                            </div>
                        ) : (
                            messages.map(msg => (
                                <div key={msg.id} className="flex gap-4">
                                    <div className="w-10 h-10 rounded-full flex items-center justify-center font-bold text-white shrink-0 shadow-md bg-indigo-500">
                                        {msg.avatar}
                                    </div>
                                    <div>
                                        <div className="flex items-baseline gap-2 mb-1">
                                            <span className="font-bold text-slate-200">{msg.user}</span>
                                            <span className="text-xs text-slate-400">{msg.time}</span>
                                        </div>
                                        <div className="text-slate-200 leading-relaxed bg-slate-700/80 p-3 px-4 rounded-2xl rounded-tl-none inline-block shadow-sm">
                                            {msg.text}
                                        </div>
                                    </div>
                                </div>
                            ))
                        )}
                        <div ref={messagesEndRef} />
                    </div>

                    <div className="p-4 bg-slate-900 border-t border-slate-700">
                        <form onSubmit={handleSend} className="flex gap-2 relative max-w-4xl mx-auto">
                            <input 
                                type="text" value={inputText} onChange={(e) => setInputText(e.target.value)}
                                placeholder="メッセージを送信..." 
                                className="flex-1 bg-slate-800 text-white rounded-full pl-6 pr-14 py-3 border border-slate-700 focus:outline-none focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 transition-all shadow-inner"
                            />
                            <button type="submit" disabled={!inputText.trim()} className="absolute right-1.5 top-1/2 -translate-y-1/2 w-10 h-10 rounded-full flex items-center justify-center bg-indigo-500 text-white disabled:opacity-50 disabled:bg-slate-700 transition-colors">
                                <Send size={18} className="ml-0.5" />
                            </button>
                        </form>
                    </div>
                </div>
            );
        };

        // --- Main App ---
        const App = () => {
            const [user, setUser] = useState(null);
            const [userName, setUserName] = useState("");

            useEffect(() => {
                const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
                    setUser(currentUser);
                });
                signInAnonymously(auth).catch((error) => console.error("Auth Error:", error));
                return () => unsubscribe();
            }, []);

            const [activeChat, setActiveChat] = useState({ type: 'channel', id: 'general', name: '雑談' });
            const channels = [{ id: 'general', name: '雑談' }, { id: 'break', name: '休憩' }];
            const [dms, setDms] = useState([]);

            const [callState, setCallState] = useState({ mode: 'none' }); 
            const [localStream, setLocalStream] = useState(null);
            const [remoteStream, setRemoteStream] = useState(null); // 相手のストリーム
            const [currentCallId, setCurrentCallId] = useState(null);
            const pcRef = useRef(null);
            
            const [isAudioEnabled, setIsAudioEnabled] = useState(true);
            const [isVideoEnabled, setIsVideoEnabled] = useState(true);
            const [isScreenSharing, setIsScreenSharing] = useState(false);
            const [errorMsg, setErrorMsg] = useState("");

            useEffect(() => {
                if (errorMsg) {
                    const timer = setTimeout(() => setErrorMsg(""), 5000);
                    return () => clearTimeout(timer);
                }
            }, [errorMsg]);

            // --- WebRTCを用いた通話開始処理 ---
            const startCall = async () => {
                try {
                    setErrorMsg("");
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    setLocalStream(stream);
                    setIsVideoEnabled(true);
                    setIsAudioEnabled(true);
                    setIsScreenSharing(false);
                    
                    // WebRTC PeerConnectionの初期化
                    const pc = new RTCPeerConnection({
                        iceServers: [{ urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }]
                    });
                    pcRef.current = pc;

                    // リモートストリーム用の受け皿を作成
                    const remote = new MediaStream();
                    setRemoteStream(remote);

                    // 自分の映像・音声を接続に追加
                    stream.getTracks().forEach(track => pc.addTrack(track, stream));

                    // 相手からのトラックを受信した時の処理
                    pc.ontrack = event => {
                        event.streams[0].getTracks().forEach(track => {
                            remote.addTrack(track);
                        });
                    };

                    // Firestoreを使ったシグナリング（接続情報のやり取り）
                    const channelDoc = doc(db, 'channels', activeChat.id);
                    const channelData = (await getDoc(channelDoc)).data();
                    let callId = channelData?.activeCallId;

                    if (!callId) {
                        // 【発信者】 誰も通話していないので、新しい通話ルームを作る
                        const newCallDoc = doc(collection(db, 'calls'));
                        callId = newCallDoc.id;
                        setCurrentCallId(callId);
                        await setDoc(channelDoc, { activeCallId: callId }, { merge: true });

                        const offerCandidates = collection(newCallDoc, 'offerCandidates');
                        const answerCandidates = collection(newCallDoc, 'answerCandidates');

                        pc.onicecandidate = event => {
                            if (event.candidate) addDoc(offerCandidates, event.candidate.toJSON());
                        };

                        const offerDescription = await pc.createOffer();
                        await pc.setLocalDescription(offerDescription);
                        await setDoc(newCallDoc, { offer: { sdp: offerDescription.sdp, type: offerDescription.type } });

                        // 相手(Answer)を待つ
                        onSnapshot(newCallDoc, snapshot => {
                            const data = snapshot.data();
                            if (!pc.currentRemoteDescription && data?.answer) {
                                const answerDescription = new RTCSessionDescription(data.answer);
                                pc.setRemoteDescription(answerDescription);
                            }
                        });

                        // 相手の通信経路候補を待つ
                        onSnapshot(answerCandidates, snapshot => {
                            snapshot.docChanges().forEach(change => {
                                if (change.type === 'added') {
                                    const candidate = new RTCIceCandidate(change.doc.data());
                                    pc.addIceCandidate(candidate);
                                }
                            });
                        });
                    } else {
                        // 【受信者】 すでに通話があるので参加する
                        setCurrentCallId(callId);
                        const callDoc = doc(db, 'calls', callId);
                        const offerCandidates = collection(callDoc, 'offerCandidates');
                        const answerCandidates = collection(callDoc, 'answerCandidates');

                        pc.onicecandidate = event => {
                            if (event.candidate) addDoc(answerCandidates, event.candidate.toJSON());
                        };

                        const callData = (await getDoc(callDoc)).data();
                        await pc.setRemoteDescription(new RTCSessionDescription(callData.offer));

                        const answerDescription = await pc.createAnswer();
                        await pc.setLocalDescription(answerDescription);
                        await updateDoc(callDoc, { answer: { sdp: answerDescription.sdp, type: answerDescription.type } });

                        // 発信者の通信経路候補を待つ
                        onSnapshot(offerCandidates, snapshot => {
                            snapshot.docChanges().forEach(change => {
                                if (change.type === 'added') {
                                    const candidate = new RTCIceCandidate(change.doc.data());
                                    pc.addIceCandidate(candidate);
                                }
                            });
                        });
                    }

                    setCallState({ mode: 'active' });
                } catch (err) {
                    console.error("Call error:", err);
                    setErrorMsg("通話の開始に失敗しました。カメラの許可を確認してください。");
                }
            };

            const endCall = async () => {
                if (pcRef.current) {
                    pcRef.current.close();
                    pcRef.current = null;
                }
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                setLocalStream(null);
                setRemoteStream(null);
                setCallState({ mode: 'none' });
                setIsScreenSharing(false);

                // 自分が通話のホスト（発信者）だった場合、通話ルーム状態をリセット
                try {
                    const channelDoc = doc(db, 'channels', activeChat.id);
                    const channelData = (await getDoc(channelDoc)).data();
                    if (channelData?.activeCallId === currentCallId) {
                        await setDoc(channelDoc, { activeCallId: null }, { merge: true });
                    }
                } catch (e) {
                    console.error(e);
                }
                setCurrentCallId(null);
            };

            const toggleAudio = () => {
                if (localStream) {
                    localStream.getAudioTracks().forEach(track => track.enabled = !track.enabled);
                    setIsAudioEnabled(!isAudioEnabled);
                }
            };

            const toggleVideo = () => {
                if (localStream) {
                    localStream.getVideoTracks().forEach(track => track.enabled = !track.enabled);
                    setIsVideoEnabled(!isVideoEnabled);
                }
            };

            const restoreCamera = async () => {
                try {
                    const camStream = await navigator.mediaDevices.getUserMedia({ video: true });
                    const camTrack = camStream.getVideoTracks()[0];
                    setLocalStream(prevStream => {
                        const audioTracks = prevStream ? prevStream.getAudioTracks() : [];
                        const newStream = new MediaStream([camTrack, ...audioTracks]);
                        
                        // 相手に送る映像もカメラに戻す
                        if (pcRef.current) {
                            const sender = pcRef.current.getSenders().find(s => s.track.kind === 'video');
                            if (sender) sender.replaceTrack(camTrack);
                        }
                        return newStream;
                    });
                    setIsScreenSharing(false);
                    setIsVideoEnabled(true);
                } catch (err) {
                    console.error("Camera fallback error", err);
                    setErrorMsg("カメラの再取得に失敗しました。");
                }
            };

            const toggleScreenShare = async () => {
                if (isScreenSharing) {
                    localStream?.getVideoTracks().forEach(track => track.stop());
                    await restoreCamera();
                } else {
                    try {
                        const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                        const screenTrack = screenStream.getVideoTracks()[0];
                        localStream?.getVideoTracks().forEach(track => track.stop());
                        
                        const newStream = new MediaStream([screenTrack, ...(localStream ? localStream.getAudioTracks() : [])]);
                        setLocalStream(newStream);
                        setIsScreenSharing(true);
                        setIsVideoEnabled(true);

                        // 相手に送る映像を画面共有に切り替える
                        if (pcRef.current) {
                            const sender = pcRef.current.getSenders().find(s => s.track.kind === 'video');
                            if (sender) sender.replaceTrack(screenTrack);
                        }
                        
                        screenTrack.onended = () => restoreCamera();
                    } catch (err) {
                        console.error("Screen share error", err);
                    }
                }
            };

            if (!userName) {
                return (
                    <div className="flex items-center justify-center h-screen bg-slate-900 text-slate-200 font-sans">
                        <div className="bg-slate-800 p-8 rounded-2xl shadow-2xl w-full max-w-sm text-center border border-slate-700">
                            <div className="flex justify-center mb-6">
                                <MessageSquare size={56} className="text-indigo-500" />
                            </div>
                            <h1 className="text-2xl font-bold mb-8 text-white">ChatAppへようこそ</h1>
                            <form onSubmit={(e) => {
                                e.preventDefault();
                                const name = e.target.username.value.trim();
                                if (name) setUserName(name);
                            }}>
                                <input 
                                    name="username"
                                    type="text" 
                                    placeholder="あなたの名前を入力してください" 
                                    className="w-full bg-slate-900 text-white rounded-xl px-4 py-3.5 border border-slate-700 focus:outline-none focus:border-indigo-500 focus:ring-2 focus:ring-indigo-500/50 mb-6 transition-all"
                                    autoFocus
                                    maxLength={20}
                                />
                                <button type="submit" className="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3.5 rounded-xl transition-all shadow-lg shadow-indigo-500/30 hover:shadow-indigo-500/50">
                                    はじめる
                                </button>
                            </form>
                        </div>
                    </div>
                );
            }

            return (
                <div className="flex h-screen bg-slate-900 text-slate-200 font-sans">
                    {errorMsg && (
                        <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-rose-600 text-white px-6 py-3 rounded-xl shadow-2xl flex items-center gap-3 z-50 animate-bounce">
                            <AlertCircle size={20} />
                            <span className="font-medium text-sm">{errorMsg}</span>
                            <button onClick={() => setErrorMsg("")} className="ml-2 hover:text-rose-200 transition-colors"><X size={16} /></button>
                        </div>
                    )}

                    {/* サイドバー */}
                    <div className="w-64 bg-slate-950 border-r border-slate-800 flex flex-col hidden md:flex shrink-0">
                        <div className="h-16 flex items-center px-6 font-black text-xl text-white border-b border-slate-800 shadow-sm">
                            <MessageSquare className="mr-3 text-indigo-500" size={24} />
                            ChatApp
                        </div>
                        <div className="p-4 flex-1">
                            <div className="text-xs font-bold text-slate-500 uppercase tracking-wider mb-3 px-2">チャンネル</div>
                            <div className="space-y-1 mb-6">
                                {channels.map(ch => (
                                    <button 
                                        key={ch.id}
                                        onClick={() => setActiveChat({ type: 'channel', id: ch.id, name: ch.name })}
                                        className={`w-full flex items-center gap-3 px-3 py-2.5 rounded-lg font-medium transition-colors ${activeChat.id === ch.id ? 'bg-indigo-500/10 text-indigo-400' : 'hover:bg-slate-800 text-slate-400'}`}
                                    >
                                        <Hash size={18} /> {ch.name}
                                    </button>
                                ))}
                            </div>

                            <div className="text-xs font-bold text-slate-500 uppercase tracking-wider mb-3 px-2">ダイレクトメッセージ</div>
                            <div className="space-y-1">
                                {dms.length === 0 ? (
                                    <div className="text-sm text-slate-600 px-3 py-2">DMはありません</div>
                                ) : (
                                    dms.map(dm => (
                                        <button 
                                            key={dm.id}
                                            onClick={() => setActiveChat({ type: 'dm', id: dm.id, name: dm.name })}
                                            className={`w-full flex items-center gap-3 px-3 py-2.5 rounded-lg font-medium transition-colors ${activeChat.id === dm.id ? 'bg-indigo-500/10 text-indigo-400' : 'hover:bg-slate-800 text-slate-400'}`}
                                        >
                                            <div className="relative">
                                                <div className="w-6 h-6 rounded-full bg-slate-700 flex items-center justify-center text-xs text-white">
                                                    {dm.name.charAt(0)}
                                                </div>
                                                {dm.online && <div className="absolute -bottom-0.5 -right-0.5 w-2.5 h-2.5 bg-green-500 border-2 border-slate-950 rounded-full"></div>}
                                            </div>
                                            {dm.name}
                                        </button>
                                    ))
                                )}
                            </div>
                        </div>
                        <div className="p-4 bg-slate-900 border-t border-slate-800 flex items-center gap-3">
                            <div className="w-10 h-10 rounded-full bg-teal-500 flex items-center justify-center font-bold text-white relative shadow-md">
                                {userName.substring(0, 2).toUpperCase()}
                                <div className="absolute bottom-0 right-0 w-3 h-3 bg-green-500 border-2 border-slate-900 rounded-full"></div>
                            </div>
                            <div className="overflow-hidden">
                                <div className="font-bold text-sm text-slate-200 truncate">{userName}</div>
                                <div className="text-xs text-slate-400">オンライン</div>
                            </div>
                        </div>
                    </div>

                    {/* メインエリア */}
                    <div className="flex-1 flex flex-col h-screen overflow-hidden bg-slate-800 relative shadow-[-10px_0_20px_rgba(0,0,0,0.2)]">
                        <header className="h-16 flex items-center justify-between px-4 md:px-6 border-b border-slate-700 bg-slate-900 shrink-0 z-10 shadow-sm">
                            <div className="flex items-center gap-2 font-bold text-lg text-white">
                                <Menu size={24} className="md:hidden text-slate-400 mr-2" />
                                {activeChat.type === 'channel' ? <Hash size={20} className="text-slate-400" /> : <UserIcon size={20} className="text-slate-400" />}
                                {activeChat.name}
                            </div>
                            {callState.mode === 'none' && (
                                <button 
                                    onClick={startCall}
                                    className="flex items-center gap-2 bg-indigo-500 hover:bg-indigo-600 px-4 py-2 rounded-lg font-bold text-sm text-white transition-all shadow-lg shadow-indigo-500/20 hover:scale-105"
                                >
                                    <Phone size={18} />
                                    <span className="hidden sm:inline">通話を開始</span>
                                </button>
                            )}
                        </header>

                        {callState.mode === 'active' ? (
                            <CallUI 
                                localStream={localStream} remoteStream={remoteStream} isAudioEnabled={isAudioEnabled} isVideoEnabled={isVideoEnabled} isScreenSharing={isScreenSharing}
                                toggleAudio={toggleAudio} toggleVideo={toggleVideo} toggleScreenShare={toggleScreenShare} endCall={endCall}
                                userName={userName}
                            />
                        ) : (
                            <ChatUI key={activeChat.id} activeChat={activeChat} user={user} userName={userName} />
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>