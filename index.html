<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Modern Chat App with Group WebRTC</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.292.0",
        "firebase/app": "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js",
        "firebase/auth": "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js",
        "firebase/firestore": "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"
      }
    }
  </script>
  
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background-color: rgba(148, 163, 184, 0.3); border-radius: 20px; }
  </style>
</head>
<body class="bg-[#F8FAFC]">
  
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef } from 'react';
    import { createRoot } from 'react-dom/client';
    import { Send, MessageSquare, User, Users, Menu, X, Settings, Image as ImageIcon, Phone, Video, Hash, PhoneCall, PhoneOff, Mic, MicOff, Camera, CameraOff, MonitorUp } from 'lucide-react';
    import { initializeApp } from 'firebase/app';
    import { getAuth, signInAnonymously, onAuthStateChanged } from 'firebase/auth';
    import { getFirestore, collection, addDoc, onSnapshot, doc, setDoc, getDoc, deleteDoc, getDocs } from 'firebase/firestore';

    // --- Firebase 設定 ---
    const firebaseConfig = {
      apiKey: "AIzaSyDqbtZUCkdO4p7nCFBPEVO4XtsBTVzIk9c",
      authDomain: "meetapp-52325.firebaseapp.com",
      projectId: "meetapp-52325",
      storageBucket: "meetapp-52325.firebasestorage.app",
      messagingSenderId: "623449233232",
      appId: "1:623449233232:web:f25c2a8641c135b509be55"
    };
    
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const appId = 'my-chat-app';

    const rtcServers = { iceServers: [{ urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }] };

    const CHANNELS = [
      { id: 'c1', name: '雑談', description: 'みんなで楽しくおしゃべり' },
      { id: 'c2', name: '休憩', description: 'ちょっと一息、リラックスルーム' },
    ];

    // 再利用可能なアバターコンポーネント
    const UserAvatar = ({ user, size = 'w-8 h-8', textClass = 'text-xs' }) => {
      if (!user) return <div className={`${size} rounded-full bg-slate-200`}></div>;
      if (user.avatarBase64) {
        return <img src={user.avatarBase64} alt={user.name} className={`${size} rounded-full object-cover shadow-sm`} />;
      }
      return <div className={`${size} rounded-full flex-shrink-0 flex items-center justify-center text-white font-bold ${textClass} ${user.avatar || 'bg-indigo-500'} shadow-sm`}>{user.name?.[0]}</div>;
    };

    // リモートビデオ再生用コンポーネント
    const RemoteVideoPlayer = ({ stream, uid, usersList }) => {
      const videoRef = useRef(null);
      const user = usersList.find(u => u.uid === uid) || { name: 'Unknown' };

      useEffect(() => {
        if (videoRef.current && stream) videoRef.current.srcObject = stream;
      }, [stream]);

      return (
        <div className="relative bg-slate-800 rounded-xl overflow-hidden aspect-video shadow-lg border border-slate-700/50">
          <video ref={videoRef} autoPlay playsInline className="w-full h-full object-cover" />
          <div className="absolute bottom-2 left-2 bg-slate-900/70 backdrop-blur-sm text-white text-xs px-2.5 py-1 rounded-md flex items-center gap-1.5">
            <UserAvatar user={user} size="w-4 h-4" textClass="text-[8px]" />
            {user.name}
          </div>
        </div>
      );
    };

    function App() {
      const [authUser, setAuthUser] = useState(null);
      const [userProfile, setUserProfile] = useState(null);
      const [showSettings, setShowSettings] = useState(false);
      
      const [activeChat, setActiveChat] = useState({ type: 'channel', data: CHANNELS[0] });
      const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
      const [inputText, setInputText] = useState('');
      const [usersList, setUsersList] = useState([]);
      const [messages, setMessages] = useState([]);

      // --- WebRTC 統合状態 ---
      const [localStream, setLocalStream] = useState(null);
      const [remoteStreams, setRemoteStreams] = useState({}); // { uid: MediaStream }
      const [callState, setCallState] = useState({
        mode: 'none',     // 'none', 'dm', 'channel'
        status: 'idle',   // dm: 'idle', 'calling', 'ringing', 'connected'. channel: 'connected'
        incomingCall: null,
        activeId: null    // DMならpeerUid, ChannelならroomId
      });
      const [currentDMCallDocId, setCurrentDMCallDocId] = useState(null);
      
      const [isVideoEnabled, setIsVideoEnabled] = useState(true);
      const [isAudioEnabled, setIsAudioEnabled] = useState(true);
      const [isScreenSharing, setIsScreenSharing] = useState(false);

      const peersRef = useRef({}); // { [uid]: RTCPeerConnection }
      const localStreamRef = useRef(null);
      const localVideoRef = useRef(null);
      const originalVideoTrackRef = useRef(null);
      const callListenersRef = useRef([]); 
      const messagesEndRef = useRef(null);

      const scrollToBottom = () => messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
      useEffect(() => scrollToBottom(), [messages]);

      // --- 1. 初期化と認証 ---
      useEffect(() => {
        const initAuth = async () => { await signInAnonymously(auth).catch(console.error); };
        initAuth();

        const unsub = onAuthStateChanged(auth, async (user) => {
          setAuthUser(user);
          if (user) {
            const docSnap = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', user.uid));
            if (docSnap.exists()) setUserProfile(docSnap.data());
          }
        });
        return () => unsub();
      }, []);

      // --- 2. データ購読 ---
      useEffect(() => {
        if (!userProfile) return;
        const unsub = onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', 'users'), (snap) => {
          const list = [];
          snap.forEach(d => { if (d.id !== userProfile.uid) list.push({ uid: d.id, ...d.data() }); });
          setUsersList(list);
        });
        return () => unsub();
      }, [userProfile]);

      useEffect(() => {
        if (!userProfile || !activeChat) return;
        const colName = activeChat.type === 'channel' ? `messages_${activeChat.data.id}` : `dm_${[userProfile.uid, activeChat.data.uid].sort().join('_')}`;
        const unsub = onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', colName), (snap) => {
          const msgs = [];
          snap.forEach(d => msgs.push({ id: d.id, ...d.data() }));
          setMessages(msgs.sort((a, b) => a.timestamp - b.timestamp));
        });
        return () => unsub();
      }, [activeChat, userProfile]);

      // アバター画像変更処理
      const handleAvatarChange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          const img = new Image();
          img.onload = async () => {
            const canvas = document.createElement('canvas');
            const MAX = 150;
            let w = img.width, h = img.height;
            if (w > h) { if (w > MAX) { h *= MAX/w; w = MAX; } }
            else { if (h > MAX) { w *= MAX/h; h = MAX; } }
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, w, h);
            const b64 = canvas.toDataURL('image/jpeg', 0.8);
            
            const updatedProfile = { ...userProfile, avatarBase64: b64 };
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', userProfile.uid), updatedProfile);
            setUserProfile(updatedProfile);
            setShowSettings(false);
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      };

      // --- 3. WebRTC共通機能 ---
      const updateLocalStream = (stream) => {
        setLocalStream(stream);
        localStreamRef.current = stream;
        if (localVideoRef.current) localVideoRef.current.srcObject = stream;
      };

      const cleanupCallLocally = () => {
        if (localStreamRef.current) localStreamRef.current.getTracks().forEach(t => t.stop());
        if (originalVideoTrackRef.current) originalVideoTrackRef.current.stop();
        updateLocalStream(null);
        Object.values(peersRef.current).forEach(pc => pc && pc.close());
        peersRef.current = {};
        setRemoteStreams({});
        setCallState({ mode: 'none', status: 'idle', incomingCall: null, activeId: null });
        setCurrentDMCallDocId(null);
        setIsScreenSharing(false);
        callListenersRef.current.forEach(unsub => unsub());
        callListenersRef.current = [];
      };

      const toggleAudio = () => {
        const track = localStreamRef.current?.getAudioTracks()[0];
        if (track) { track.enabled = !track.enabled; setIsAudioEnabled(track.enabled); }
      };
      
      const toggleVideo = () => {
        const track = localStreamRef.current?.getVideoTracks()[0];
        if (track) { track.enabled = !track.enabled; setIsVideoEnabled(track.enabled); }
      };

      // --- 画面共有機能 ---
      const stopScreenShare = async () => {
        setIsScreenSharing(false);
        const currentVideoTrack = localStreamRef.current?.getVideoTracks()[0];
        if (currentVideoTrack) {
          currentVideoTrack.stop();
          localStreamRef.current.removeTrack(currentVideoTrack);
        }

        let camTrack = originalVideoTrackRef.current;
        if (!camTrack || camTrack.readyState === 'ended') {
          try {
            const camStream = await navigator.mediaDevices.getUserMedia({ video: true });
            camTrack = camStream.getVideoTracks()[0];
          } catch(e) { console.warn("Camera fallback failed", e); }
        }

        if (camTrack) {
          localStreamRef.current.addTrack(camTrack);
          setIsVideoEnabled(camTrack.enabled);
          if (localVideoRef.current) localVideoRef.current.srcObject = localStreamRef.current;
          
          Object.values(peersRef.current).forEach(pc => {
            const sender = pc.getSenders().find(s => s.track?.kind === 'video');
            if (sender) sender.replaceTrack(camTrack);
          });
        }
      };

      const startScreenShare = async () => {
        try {
          const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
          const screenTrack = screenStream.getVideoTracks()[0];

          const currentVideoTrack = localStreamRef.current?.getVideoTracks()[0];
          if (currentVideoTrack) {
            originalVideoTrackRef.current = currentVideoTrack;
            localStreamRef.current.removeTrack(currentVideoTrack);
          }
          localStreamRef.current.addTrack(screenTrack);
          setIsScreenSharing(true);
          setIsVideoEnabled(true);

          if (localVideoRef.current) localVideoRef.current.srcObject = localStreamRef.current;

          Object.values(peersRef.current).forEach(pc => {
            const sender = pc.getSenders().find(s => s.track?.kind === 'video');
            if (sender) sender.replaceTrack(screenTrack);
          });

          // ブラウザのUIで「共有を停止」が押された時の処理
          screenTrack.onended = () => stopScreenShare();
        } catch (err) { console.error("Screen share failed", err); }
      };

      const toggleScreenShare = () => {
        if (isScreenSharing) stopScreenShare();
        else startScreenShare();
      };

      // ==========================================
      // [A] グループ通話 (Channel) のロジック
      // ==========================================
      const joinChannelCall = async (roomId, isVideo) => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: isVideo, audio: true });
          updateLocalStream(stream);
          setIsVideoEnabled(isVideo);
          setIsAudioEnabled(true);
          setCallState({ mode: 'channel', status: 'connected', activeId: roomId, incomingCall: null });

          // 自分を参加者リストに追加
          await setDoc(doc(db, 'artifacts', appId, 'public', 'data', `room_participants_${roomId}`, userProfile.uid), { joinedAt: Date.now() });

          // 既存の参加者にOfferを送信
          const snap = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', `room_participants_${roomId}`));
          snap.forEach(docSnap => {
            const peerUid = docSnap.id;
            if (peerUid !== userProfile.uid) createChannelPeerConnection(peerUid, roomId, stream, true);
          });
        } catch(err) {
          console.error(err);
          alert("カメラ・マイクへのアクセスに失敗しました。");
        }
      };

      const createChannelPeerConnection = async (peerUid, roomId, stream, isInitiator) => {
        const pc = new RTCPeerConnection(rtcServers);
        peersRef.current[peerUid] = pc;
        stream.getTracks().forEach(t => pc.addTrack(t, stream));

        pc.ontrack = (e) => setRemoteStreams(prev => ({ ...prev, [peerUid]: e.streams[0] }));

        pc.onicecandidate = (e) => {
          if (e.candidate) {
            addDoc(collection(db, 'artifacts', appId, 'public', 'data', `room_signals_${roomId}_${peerUid}`), {
              from: userProfile.uid, type: 'candidate', candidate: e.candidate.toJSON(), timestamp: Date.now()
            });
          }
        };

        if (isInitiator) {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          addDoc(collection(db, 'artifacts', appId, 'public', 'data', `room_signals_${roomId}_${peerUid}`), {
            from: userProfile.uid, type: 'offer', sdp: { type: offer.type, sdp: offer.sdp }, timestamp: Date.now()
          });
        }
        return pc;
      };

      // チャンネル用シグナリング＆参加者監視
      useEffect(() => {
        if (callState.mode !== 'channel' || !callState.activeId || !userProfile) return;
        const roomId = callState.activeId;
        
        // 自分宛てのシグナルを監視
        const unsubSignals = onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', `room_signals_${roomId}_${userProfile.uid}`), (snap) => {
          snap.docChanges().forEach(async (change) => {
            if (change.type === 'added') {
              const { from, type, sdp, candidate } = change.doc.data();
              let pc = peersRef.current[from];

              if (type === 'offer') {
                if (!pc) pc = await createChannelPeerConnection(from, roomId, localStreamRef.current, false);
                await pc.setRemoteDescription(new RTCSessionDescription(sdp));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                addDoc(collection(db, 'artifacts', appId, 'public', 'data', `room_signals_${roomId}_${from}`), {
                  from: userProfile.uid, type: 'answer', sdp: { type: answer.type, sdp: answer.sdp }, timestamp: Date.now()
                });
              } else if (type === 'answer' && pc && !pc.currentRemoteDescription) {
                await pc.setRemoteDescription(new RTCSessionDescription(sdp));
              } else if (type === 'candidate' && pc) {
                await pc.addIceCandidate(new RTCIceCandidate(candidate));
              }
              deleteDoc(change.doc.ref).catch(console.error); // 処理済みシグナル削除
            }
          });
        });

        // 参加者の離脱監視
        const unsubParticipants = onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', `room_participants_${roomId}`), (snap) => {
          snap.docChanges().forEach(change => {
            if (change.type === 'removed') {
              const peerUid = change.doc.id;
              if (peersRef.current[peerUid]) { peersRef.current[peerUid].close(); delete peersRef.current[peerUid]; }
              setRemoteStreams(prev => { const next = { ...prev }; delete next[peerUid]; return next; });
            }
          });
        });

        return () => { unsubSignals(); unsubParticipants(); };
      }, [callState.mode, callState.activeId, userProfile]);

      const leaveChannelCall = async () => {
        if (callState.mode === 'channel' && callState.activeId) {
          await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', `room_participants_${callState.activeId}`, userProfile.uid)).catch(console.error);
        }
        cleanupCallLocally();
      };


      // ==========================================
      // [B] 1対1 (DM) 通話 のロジック
      // ==========================================
      useEffect(() => {
        if (!userProfile) return;
        const unsub = onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', 'calls'), (snap) => {
          snap.docChanges().forEach((change) => {
            const data = change.doc.data();
            // 着信
            if (change.type === 'added' && data.calleeUid === userProfile.uid && data.status === 'calling' && callState.mode === 'none') {
              setCallState(prev => ({ ...prev, status: 'ringing', incomingCall: { id: change.doc.id, ...data } }));
            }
            // 終了
            if (data.status === 'ended' && (data.callerUid === userProfile.uid || data.calleeUid === userProfile.uid)) {
              cleanupCallLocally();
            }
            // 応答 (発信者側)
            if (data.callerUid === userProfile.uid && data.status === 'connected' && data.answer) {
              const peerUid = data.calleeUid;
              const pc = peersRef.current[peerUid];
              if (pc && !pc.currentRemoteDescription) {
                pc.setRemoteDescription(new RTCSessionDescription(data.answer)).catch(console.error);
                setCallState(prev => ({ ...prev, status: 'connected' }));
              }
            }
          });
        });
        return () => unsub();
      }, [userProfile, callState.mode]);

      const startDMCall = async (isVideo) => {
        if (activeChat.type !== 'dm') return;
        const peerUid = activeChat.data.uid;
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: isVideo, audio: true });
          updateLocalStream(stream);
          setIsVideoEnabled(isVideo); setIsAudioEnabled(true);
          setCallState({ mode: 'dm', status: 'calling', activeId: peerUid, incomingCall: null });

          const pc = new RTCPeerConnection(rtcServers);
          peersRef.current[peerUid] = pc;
          stream.getTracks().forEach(t => pc.addTrack(t, stream));
          pc.ontrack = e => setRemoteStreams({ [peerUid]: e.streams[0] });

          const callDoc = doc(collection(db, 'artifacts', appId, 'public', 'data', 'calls'));
          setCurrentDMCallDocId(callDoc.id);

          pc.onicecandidate = e => {
            if (e.candidate) addDoc(collection(db, 'artifacts', appId, 'public', 'data', `candidates_${callDoc.id}_offer`), e.candidate.toJSON());
          };

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          await setDoc(callDoc, { callerUid: userProfile.uid, callerName: userProfile.name, calleeUid: peerUid, offer: { sdp: offer.sdp, type: offer.type }, status: 'calling', timestamp: Date.now() });

          const unsub = onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', `candidates_${callDoc.id}_answer`), (snap) => {
            snap.docChanges().forEach(change => { if (change.type === 'added') pc.addIceCandidate(new RTCIceCandidate(change.doc.data())); });
          });
          callListenersRef.current.push(unsub);
        } catch (err) { console.error(err); cleanupCallLocally(); }
      };

      const answerDMCall = async (isVideo) => {
        const { incomingCall } = callState;
        if (!incomingCall) return;
        const callId = incomingCall.id;
        const peerUid = incomingCall.callerUid;
        
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: isVideo, audio: true });
          updateLocalStream(stream);
          setIsVideoEnabled(isVideo); setIsAudioEnabled(true);
          setCallState({ mode: 'dm', status: 'connected', activeId: peerUid, incomingCall: null });
          setCurrentDMCallDocId(callId);

          const pc = new RTCPeerConnection(rtcServers);
          peersRef.current[peerUid] = pc;
          stream.getTracks().forEach(t => pc.addTrack(t, stream));
          pc.ontrack = e => setRemoteStreams({ [peerUid]: e.streams[0] });

          pc.onicecandidate = e => {
            if (e.candidate) addDoc(collection(db, 'artifacts', appId, 'public', 'data', `candidates_${callId}_answer`), e.candidate.toJSON());
          };

          await pc.setRemoteDescription(new RTCSessionDescription(incomingCall.offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);

          await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'calls', callId), { answer: { type: answer.type, sdp: answer.sdp }, status: 'connected' }, { merge: true });

          const unsub = onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', `candidates_${callId}_offer`), (snap) => {
            snap.docChanges().forEach(change => { if (change.type === 'added') pc.addIceCandidate(new RTCIceCandidate(change.doc.data())); });
          });
          callListenersRef.current.push(unsub);
        } catch (err) { console.error(err); handleHangupDM(); }
      };

      const handleHangupDM = async () => {
        const callId = currentDMCallDocId || callState.incomingCall?.id;
        cleanupCallLocally();
        if (callId) await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'calls', callId), { status: 'ended' }, { merge: true }).catch(console.error);
      };


      // --- 基本アクション ---
      const handleLogin = async (username) => {
        if (!username.trim() || !authUser) return;
        const colors = ['bg-violet-600', 'bg-emerald-500', 'bg-blue-500', 'bg-rose-500', 'bg-amber-500'];
        const profile = { uid: authUser.uid, name: username, avatar: colors[Math.floor(Math.random() * colors.length)], isOnline: true, joinedAt: Date.now() };
        await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', authUser.uid), profile);
        setUserProfile(profile);
      };

      const handleSendMessage = async (e) => {
        e.preventDefault();
        if (!inputText.trim() || !userProfile) return;
        const colName = activeChat.type === 'channel' ? `messages_${activeChat.data.id}` : `dm_${[userProfile.uid, activeChat.data.uid].sort().join('_')}`;
        await addDoc(collection(db, 'artifacts', appId, 'public', 'data', colName), {
          text: inputText, sender: userProfile.name, senderUid: userProfile.uid, timestamp: Date.now()
        });
        setInputText('');
      };


      // ==========================================
      // UI レンダリング
      // ==========================================

      if (!userProfile) {
        return (
          <div className="min-h-screen bg-slate-900 flex items-center justify-center p-4">
            <div className="bg-white border p-8 rounded-3xl w-full max-w-sm shadow-2xl">
              <h1 className="text-2xl font-black text-slate-800 text-center mb-6">Welcome to Chat</h1>
              <form onSubmit={e => { e.preventDefault(); handleLogin(e.target.username.value); }} className="space-y-4">
                <input type="text" name="username" disabled={!authUser} className="w-full px-4 py-3 rounded-xl bg-slate-50 border border-slate-200 outline-none focus:border-indigo-500" placeholder="ニックネーム" required autoFocus />
                <button type="submit" disabled={!authUser} className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-xl transition-colors">参加する</button>
              </form>
            </div>
          </div>
        );
      }

      return (
        <div className="flex h-screen w-full relative overflow-hidden">
          
          {/* プロフィール設定モーダル */}
          {showSettings && (
            <div className="fixed inset-0 bg-slate-900/60 backdrop-blur-sm z-[200] flex items-center justify-center p-4">
              <div className="bg-white rounded-3xl p-8 w-full max-w-sm shadow-2xl relative">
                <button onClick={() => setShowSettings(false)} className="absolute top-4 right-4 text-slate-400 hover:text-slate-700"><X size={24}/></button>
                <h3 className="text-xl font-bold mb-6 text-slate-800 text-center">プロフィール設定</h3>
                <div className="flex flex-col items-center gap-6 mb-8">
                  <div className="relative group cursor-pointer">
                    <UserAvatar user={userProfile} size="w-28 h-28" textClass="text-4xl" />
                    <label className="absolute inset-0 bg-black/50 rounded-full flex flex-col items-center justify-center text-white opacity-0 group-hover:opacity-100 transition-opacity cursor-pointer">
                      <ImageIcon size={24} className="mb-1" />
                      <span className="text-xs font-bold">変更</span>
                      <input type="file" accept="image/*" className="hidden" onChange={handleAvatarChange} />
                    </label>
                  </div>
                  <div className="text-center">
                    <div className="text-xl font-bold text-slate-800">{userProfile.name}</div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* DM着信オーバーレイ */}
          {callState.status === 'ringing' && callState.incomingCall && (
            <div className="fixed inset-0 bg-slate-900/80 backdrop-blur-md z-[100] flex items-center justify-center">
              <div className="bg-white p-8 rounded-3xl shadow-2xl flex flex-col items-center w-full max-w-sm mx-4">
                <div className="animate-bounce mb-4"><UserAvatar user={{name: callState.incomingCall.callerName}} size="w-24 h-24" textClass="text-4xl" /></div>
                <h2 className="text-2xl font-bold mb-1 text-slate-800">{callState.incomingCall.callerName}</h2>
                <p className="text-slate-500 mb-8 font-medium">着信中...</p>
                <div className="flex gap-4 w-full">
                  <button onClick={handleHangupDM} className="flex-1 py-4 bg-rose-500 hover:bg-rose-600 rounded-2xl text-white transition-all flex justify-center shadow-lg hover:shadow-rose-500/30"><PhoneOff size={28} /></button>
                  <button onClick={() => answerDMCall(false)} className="flex-1 py-4 bg-indigo-500 hover:bg-indigo-600 rounded-2xl text-white transition-all flex justify-center shadow-lg hover:shadow-indigo-500/30"><PhoneCall size={28} /></button>
                  <button onClick={() => answerDMCall(true)} className="flex-1 py-4 bg-emerald-500 hover:bg-emerald-600 rounded-2xl text-white transition-all flex justify-center shadow-lg hover:shadow-emerald-500/30"><Video size={28} /></button>
                </div>
              </div>
            </div>
          )}

          {/* DM通話中 フルスクリーンUI */}
          {callState.mode === 'dm' && callState.status !== 'ringing' && (
            <div className="fixed inset-0 bg-slate-950 z-[90] flex flex-col">
              <div className="flex-1 relative overflow-hidden flex items-center justify-center">
                {remoteStreams[callState.activeId] ? (
                  <video autoPlay playsInline ref={el => { if(el) el.srcObject = remoteStreams[callState.activeId]; }} className="absolute inset-0 w-full h-full object-cover" />
                ) : (
                  <div className="text-center text-white z-10">
                    <UserAvatar user={activeChat.data} size="w-32 h-32 mx-auto mb-6 animate-pulse" textClass="text-5xl" />
                    <h2 className="text-3xl font-bold mb-2">{activeChat.data.name}</h2><p className="text-slate-400">発信中...</p>
                  </div>
                )}
                
                {/* ワイプ */}
                <div className="absolute bottom-6 right-6 w-32 h-48 sm:w-48 sm:h-72 bg-slate-800 rounded-2xl overflow-hidden shadow-2xl border-2 border-slate-700/50 z-20">
                  {isVideoEnabled ? (
                    <video ref={localVideoRef} autoPlay playsInline muted className={`w-full h-full object-cover ${!isScreenSharing ? 'transform scale-x-[-1]' : ''}`} />
                  ) : (<div className="w-full h-full flex items-center justify-center text-slate-500"><CameraOff size={32} /></div>)}
                </div>
              </div>
              <div className="h-28 bg-slate-900/90 backdrop-blur-md flex items-center justify-center gap-6 shrink-0 border-t border-slate-800 pb-4">
                <button onClick={toggleAudio} className={`w-14 h-14 rounded-full flex items-center justify-center transition-all ${isAudioEnabled ? 'bg-slate-700 text-white' : 'bg-rose-500/20 text-rose-500'}`}>{isAudioEnabled ? <Mic size={24} /> : <MicOff size={24} />}</button>
                <button onClick={toggleVideo} className={`w-14 h-14 rounded-full flex items-center justify-center transition-all ${isVideoEnabled ? 'bg-slate-700 text-white' : 'bg-rose-500/20 text-rose-500'}`}>{isVideoEnabled ? <Camera size={24} /> : <CameraOff size={24} />}</button>
                <button onClick={toggleScreenShare} className={`w-14 h-14 rounded-full flex items-center justify-center transition-all ${isScreenSharing ? 'bg-indigo-500 text-white' : 'bg-slate-700 text-white'}`}><MonitorUp size={24} /></button>
                <button onClick={handleHangupDM} className="w-16 h-16 rounded-full flex items-center justify-center bg-rose-500 text-white transition-all hover:scale-105 ml-8"><PhoneOff size={28} /></button>
              </div>
            </div>
          )}
          
          {mobileMenuOpen && <div className="fixed inset-0 bg-slate-900/60 z-20 md:hidden" onClick={() => setMobileMenuOpen(false)} />}

          {/* サイドバー */}
          <div className={`fixed md:relative z-30 w-72 h-full bg-slate-900 flex flex-col transition-transform ${mobileMenuOpen ? 'translate-x-0' : '-translate-x-full md:translate-x-0'}`}>
            <div className="p-5 border-b border-slate-800 flex justify-between items-center">
              <h2 className="text-xl font-bold text-white flex items-center gap-2"><MessageSquare className="text-indigo-400"/> Connect</h2>
              <button onClick={() => setMobileMenuOpen(false)} className="md:hidden text-slate-400"><X size={20} /></button>
            </div>
            
            <div className="flex-1 overflow-y-auto py-6 custom-scrollbar">
              <div className="px-5 mb-2 text-xs font-bold text-slate-500 uppercase tracking-wider">Channels</div>
              {CHANNELS.map(c => (
                <button key={c.id} onClick={() => { setActiveChat({type: 'channel', data: c}); setMobileMenuOpen(false); }}
                  className={`w-full text-left px-5 py-2.5 flex items-center gap-3 transition-colors ${activeChat.data.id === c.id ? 'bg-indigo-500/10 text-indigo-400 border-r-2 border-indigo-500' : 'text-slate-400 hover:bg-slate-800'}`}>
                  <Hash size={18}/> <span className="font-medium">{c.name}</span>
                </button>
              ))}

              <div className="mt-8 px-5 mb-2 text-xs font-bold text-slate-500 uppercase tracking-wider">Direct Messages</div>
              {usersList.map(u => (
                <button key={u.uid} onClick={() => { setActiveChat({type: 'dm', data: u}); setMobileMenuOpen(false); }}
                  className={`w-full text-left px-5 py-2.5 flex items-center gap-3 transition-colors ${activeChat.data?.uid === u.uid ? 'bg-indigo-500/10 text-indigo-400 border-r-2 border-indigo-500' : 'text-slate-400 hover:bg-slate-800'}`}>
                  <div className="relative">
                    <UserAvatar user={u} size="w-7 h-7" />
                    <div className="absolute bottom-0 right-0 w-2 h-2 bg-emerald-400 border border-slate-900 rounded-full"></div>
                  </div>
                  <span className="font-medium truncate">{u.name}</span>
                </button>
              ))}
            </div>

            {/* 自分のプロフィールエリア */}
            <div className="p-4 bg-slate-800/50 border-t border-slate-800 flex items-center gap-3">
              <UserAvatar user={userProfile} size="w-10 h-10" />
              <div className="flex-1 min-w-0 text-white font-bold truncate">{userProfile.name}</div>
              <button onClick={() => setShowSettings(true)} className="p-2 text-slate-400 hover:text-white transition-colors rounded-lg hover:bg-slate-700">
                <Settings size={20} />
              </button>
            </div>
          </div>

          {/* チャットエリア */}
          <div className="flex-1 flex flex-col min-w-0 bg-white">
            <header className="h-16 bg-white border-b px-4 flex items-center justify-between shrink-0 shadow-sm z-10 relative">
              <div className="flex items-center gap-3">
                <button onClick={() => setMobileMenuOpen(true)} className="md:hidden text-slate-500"><Menu size={22} /></button>
                <div className="flex items-center gap-2">
                  {activeChat.type === 'channel' ? <Hash className="text-slate-400" size={20}/> : <UserAvatar user={activeChat.data} size="w-6 h-6" />}
                  <h3 className="font-bold text-lg text-slate-800">{activeChat.data.name}</h3>
                </div>
              </div>
              
              {/* DM用通話ボタン */}
              {activeChat.type === 'dm' && callState.mode === 'none' && (
                <div className="flex gap-2">
                  <button onClick={() => startDMCall(false)} className="p-2 text-slate-500 hover:text-indigo-600 hover:bg-indigo-50 rounded-lg transition-colors"><Phone size={20} /></button>
                  <button onClick={() => startDMCall(true)} className="p-2 text-slate-500 hover:text-indigo-600 hover:bg-indigo-50 rounded-lg transition-colors"><Video size={20} /></button>
                </div>
              )}
            </header>

            {/* Channel グループ通話 UI */}
            {activeChat.type === 'channel' && (
              <div className="shrink-0 z-0">
                {/* 未参加の場合の帯 */}
                {callState.mode !== 'channel' && (
                  <div className="bg-indigo-50/50 border-b border-indigo-100 p-3 flex justify-between items-center px-6">
                    <span className="text-sm text-indigo-800 font-bold flex items-center gap-2"><PhoneCall size={16}/> グループ通話に参加できます</span>
                    <div className="flex gap-2">
                      <button onClick={() => joinChannelCall(activeChat.data.id, false)} className="flex items-center gap-1.5 bg-white border shadow-sm px-4 py-1.5 rounded-lg text-sm font-bold text-slate-700 hover:bg-slate-50 transition-colors"><Mic size={16}/> 音声で参加</button>
                      <button onClick={() => joinChannelCall(activeChat.data.id, true)} className="flex items-center gap-1.5 bg-indigo-500 shadow-sm px-4 py-1.5 rounded-lg text-sm font-bold text-white hover:bg-indigo-600 transition-colors"><Video size={16}/> ビデオで参加</button>
                    </div>
                  </div>
                )}
                
                {/* 参加中のビデオグリッド */}
                {callState.mode === 'channel' && callState.activeId === activeChat.data.id && (
                  <div className="bg-slate-900 p-4 border-b border-slate-800 shadow-inner">
                    <div className="flex justify-between items-center mb-4 px-2">
                      <div className="text-white font-bold flex items-center gap-2">
                        <div className="w-2 h-2 rounded-full bg-emerald-500 animate-pulse"></div>
                        ボイスチャンネル接続中
                      </div>
                      <div className="flex gap-3">
                        <button onClick={toggleAudio} className={`p-2 rounded-lg transition-colors ${isAudioEnabled ? 'bg-slate-700 text-white' : 'bg-rose-500/20 text-rose-500'}`}>{isAudioEnabled ? <Mic size={18}/> : <MicOff size={18}/>}</button>
                        <button onClick={toggleVideo} className={`p-2 rounded-lg transition-colors ${isVideoEnabled ? 'bg-slate-700 text-white' : 'bg-rose-500/20 text-rose-500'}`}>{isVideoEnabled ? <Camera size={18}/> : <CameraOff size={18}/>}</button>
                        <button onClick={toggleScreenShare} className={`p-2 rounded-lg transition-colors ${isScreenSharing ? 'bg-indigo-500 text-white' : 'bg-slate-700 text-white'}`} title="画面共有"><MonitorUp size={18}/></button>
                        <button onClick={leaveChannelCall} className="bg-rose-500 hover:bg-rose-600 text-white px-4 py-2 rounded-lg text-sm font-bold flex items-center gap-2 transition-colors"><PhoneOff size={16}/> 切断</button>
                      </div>
                    </div>
                    
                    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3 px-2">
                      {/* 自分 */}
                      <div className="relative bg-slate-800 rounded-xl overflow-hidden aspect-video shadow-lg border border-slate-700/50">
                        {isVideoEnabled ? (
                           <video ref={localVideoRef} autoPlay muted playsInline className={`w-full h-full object-cover ${!isScreenSharing ? 'transform scale-x-[-1]' : ''}`} />
                        ) : (
                           <div className="w-full h-full flex items-center justify-center bg-slate-800 text-slate-600"><CameraOff size={24}/></div>
                        )}
                        <div className="absolute bottom-2 left-2 bg-indigo-500/90 backdrop-blur-sm text-white text-xs px-2.5 py-1 rounded-md flex items-center gap-1.5 font-bold shadow-sm">あなた</div>
                      </div>
                      
                      {/* 他の参加者 */}
                      {Object.entries(remoteStreams).map(([uid, stream]) => (
                        <RemoteVideoPlayer key={uid} stream={stream} uid={uid} usersList={usersList} />
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}

            {/* メッセージリスト */}
            <div className="flex-1 overflow-y-auto p-4 space-y-6 bg-slate-50 custom-scrollbar">
              {messages.map((m, i) => {
                const isMe = m.senderUid === userProfile.uid;
                const senderProfile = isMe ? userProfile : usersList.find(u => u.uid === m.senderUid) || { name: m.sender };
                const showHeader = i === 0 || messages[i-1].senderUid !== m.senderUid || (m.timestamp - messages[i-1].timestamp > 60000 * 5);

                return (
                  <div key={m.id} className={`flex gap-3 ${isMe ? 'flex-row-reverse' : ''}`}>
                    {showHeader ? <UserAvatar user={senderProfile} size="w-9 h-9" /> : <div className="w-9 shrink-0"></div>}
                    <div className={`flex flex-col max-w-[75%] ${isMe ? 'items-end' : 'items-start'}`}>
                      {showHeader && <span className="text-xs text-slate-500 mb-1 ml-1 font-medium">{m.sender}</span>}
                      <div className={`px-4 py-2.5 rounded-2xl shadow-sm text-[15px] ${isMe ? 'bg-indigo-500 text-white rounded-tr-sm' : 'bg-white border border-slate-100 text-slate-800 rounded-tl-sm'}`}>
                        {m.text}
                      </div>
                    </div>
                  </div>
                );
              })}
              <div ref={messagesEndRef} />
            </div>

            {/* メッセージ入力 */}
            <div className="p-4 bg-white border-t border-slate-100">
              <form onSubmit={handleSendMessage} className="flex gap-2 max-w-4xl mx-auto bg-slate-50 p-1.5 rounded-2xl border border-slate-200 focus-within:border-indigo-400 focus-within:ring-2 focus-within:ring-indigo-100 transition-all">
                <input type="text" value={inputText} onChange={e => setInputText(e.target.value)} placeholder={`#${activeChat.data.name} へメッセージを送信`} className="flex-1 bg-transparent px-4 outline-none text-slate-700" />
                <button type="submit" disabled={!inputText} className="p-3 bg-indigo-500 hover:bg-indigo-600 text-white rounded-xl disabled:opacity-50 disabled:hover:bg-indigo-500 transition-colors"><Send size={18} /></button>
              </form>
            </div>
          </div>
        </div>
      );
    }

    const root = createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>